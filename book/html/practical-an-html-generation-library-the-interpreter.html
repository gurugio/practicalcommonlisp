<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
    <head>
        <title>
            Practical: An HTML Generation Library, the Interpreter
        </title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <h1>
            30. Practical: An HTML Generation Library, the Interpreter
        </h1>
        <p>
            In this chapter and the next you'll take a look under the hood of the FOO HTML generator that you've been using in the past few chapters. FOO is an example of a kind of programming that's quite common in Common Lisp and relatively uncommon in non-Lisp languages, namely, <i>language-oriented</i> programming. Rather than provide an API built primarily out of functions, classes, and macros, FOO provides language processors for a domain-specific language that you can embed in your Common Lisp programs.
        </p>
        <p>
            FOO provides two language processors for the same s-expression language. One is an interpreter that takes a FOO "program" as data and interprets it to generate HTML. The other is a compiler that compiles FOO expressions, possibly with embedded Common Lisp code, into Common Lisp that generates HTML and runs the embedded code. The interpreter is exposed as the function <code>emit-html</code> and the compiler as the macro <code>html</code>, which you used in previous chapters.
        </p>
        <p>
            In this chapter you'll look at some of the infrastructure shared between the interpreter and the compiler and then at the implementation of the interpreter. In the next chapter, I'll show you how the compiler works.
        </p>
        <h2>
            <a name="designing-a-domain-specific-language" id="designing-a-domain-specific-language">Designing a Domain-Specific Language</a>
        </h2>
        <p>
            Designing an embedded language requires two steps: first, design the language that'll allow you to express the things you want to express, and second, implement a processor, or processors, that accepts a "program" in that language and either performs the actions indicated by the program or translates the program into Common Lisp code that'll perform equivalent behaviors.
        </p>
        <p>
            So, step one is to design the HTML-generating language. The key to designing a good domain-specific language is to strike the right balance between expressiveness and concision. For instance, a highly expressive but not very concise "language" for generating HTML is the language of literal HTML strings. The legal "forms" of this language are strings containing literal HTML. Language processors for this "language" could process such forms by simply emitting them as-is.
        </p>
        <pre>
(defvar *html-output* *standard-output*)

(defun emit-html (html)
  "An interpreter for the literal HTML language."
  (write-sequence html *html-output*))

(defmacro html (html)
  "A compiler for the literal HTML language."
  `(write-sequence ,html *html-output*))
</pre>
        <p>
            This "language" is highly expressive since it can express <i>any</i> HTML you could possibly want to generate.<sup>1</sup> On the other hand, this language doesn't win a lot of points for its concision because it gives you zero compression--its input <i>is</i> its output.
        </p>
        <p>
            To design a language that gives you some useful compression without sacrificing too much expressiveness, you need to identify the details of the output that are either redundant or uninteresting. You can then make those aspects of the output implicit in the semantics of the language.
        </p>
        <p>
            For instance, because of the structure of HTML, every opening tag is paired with a matching closing tag.<sup>2</sup> When you write HTML by hand, you have to write those closing tags, but you can improve the concision of your HTML-generating language by making the closing tags implicit.
        </p>
        <p>
            Another way you can gain concision at a slight cost in expressiveness is to make the language processors responsible for adding appropriate whitespace between elements--blank lines and indentation. When you're generating HTML programmatically, you typically don't care much about which elements have line breaks before or after them or about whether different elements are indented relative to their parent elements. Letting the language processor insert whitespace according to some rule means you don't have to worry about it. As it turns out, FOO actually supports two modes--one that uses the minimum amount of whitespace, which allows it to generate extremely efficient code and compact HTML, and another that generates nicely formatted HTML with different elements indented and separated from other elements according to their role.
        </p>
        <p>
            Another detail that's best moved into the language processor is the escaping of certain characters that have a special meaning in HTML such as <code>&lt;</code>, <code>&gt;</code>, and <code>&amp;</code>. Obviously, if you generate HTML by just printing strings to a stream, then it's up to you to replace any occurrences of those characters in the string with the appropriate escape sequences, <code>&amp;lt;</code>, <code>&amp;gt;</code> and <code>&amp;amp;</code>. But if the language processor can know which strings are to be emitted as element data, then it can take care of automatically escaping those characters for you.
        </p>
        <h2>
            <a name="the-foo-language" id="the-foo-language">The FOO Language</a>
        </h2>
        <p>
            So, enough theory. I'll give you a quick overview of the language implemented by FOO, and then you'll look at the implementation of the two FOO language processors--the interpreter, in this chapter, and the compiler, in the next.
        </p>
        <p>
            Like Lisp itself, the basic syntax of the FOO language is defined in terms of forms made up of Lisp objects. The language defines how each legal FOO form is translated into HTML.
        </p>
        <p>
            The simplest FOO forms are self-evaluating Lisp objects such as strings, numbers, and keyword symbols.<sup>3</sup> You'll need a function <code>self-evaluating-p</code> that tests whether a given object is self-evaluating for FOO's purposes.
        </p>
        <pre>
(defun self-evaluating-p (form)
  (and (atom form) (if (symbolp form) (keywordp form) t)))
</pre>
        <p>
            Objects that satisfy this predicate will be emitted by converting them to strings with <code><b>PRINC-TO-STRING</b></code> and then escaping any reserved characters, such as <code>&lt;</code>, <code>&gt;</code>, or <code>&amp;</code>. When the value is being emitted as an attribute, the characters <code>"</code>, and <code>'</code> are also escaped. Thus, you can invoke the <code>html</code> macro on a self-evaluating object to emit it to <code>*html-output*</code> (which is initially bound to <code><b>*STANDARD-OUTPUT*</b></code>). Table 30-1 shows how a few different self-evaluating values will be output.
        </p>
        <div class="table-caption">
            Table 30-1. FOO Output for Self-Evaluating Objects
        </div>
        <table class="book-table">
            <tr>
                <td>
                    FOO Form
                </td>
                <td>
                    Generated HTML
                </td>
            </tr>
            <tr>
                <td>
                    <code>"foo"</code>
                </td>
                <td>
                    <code>foo</code>
                </td>
            </tr>
            <tr>
                <td>
                    <code>10</code>
                </td>
                <td>
                    <code>10</code>
                </td>
            </tr>
            <tr>
                <td>
                    <code>:foo</code>
                </td>
                <td>
                    <code>FOO</code>
                </td>
            </tr>
            <tr>
                <td>
                    <code>"foo &amp; bar"</code>
                </td>
                <td>
                    <code>foo &amp;amp; bar</code>
                </td>
            </tr>
        </table>
        <p>
            Of course, most HTML consists of tagged elements. The three pieces of information that describe each element are the tag, a set of attributes, and a body containing text and/or more HTML elements. Thus, you need a way to represent these three pieces of information as Lisp objects, preferably ones that the Lisp reader already knows how to read.<sup>4</sup> If you forget about attributes for a moment, there's an obvious mapping between Lisp lists and HTML elements: any HTML element can be represented by a list whose <code><b>FIRST</b></code> is a symbol where the name is the name of the element's tag and whose <code><b>REST</b></code> is a list of self-evaluating objects or lists representing other HTML elements. Thus:
        </p>
        <pre>
&lt;p&gt;Foo&lt;/p&gt; &lt;==&gt; (:p "Foo")

&lt;p&gt;&lt;i&gt;Now&lt;/i&gt; is the time&lt;/p&gt; &lt;==&gt; (:p (:i "Now") " is the time")
</pre>
        <p>
            Now the only problem is where to squeeze in the attributes. Since most elements have no attributes, it'd be nice if you could use the preceding syntax for elements without attributes. FOO provides two ways to notate elements with attributes. The first is to simply include the attributes in the list immediately following the symbol, alternating keyword symbols naming the attributes and objects representing the attribute value forms. The body of the element starts with the first item in the list that's in a position to be an attribute name and isn't a keyword symbol. Thus:
        </p>
        <pre>
HTML&gt; (html (:p "foo"))
&lt;p&gt;foo&lt;/p&gt;
NIL
HTML&gt; (html (:p "foo " (:i "bar") " baz"))
&lt;p&gt;foo &lt;i&gt;bar&lt;/i&gt; baz&lt;/p&gt;
NIL
HTML&gt; (html (:p :style "foo" "Foo"))
&lt;p style='foo'&gt;Foo&lt;/p&gt;
NIL
HTML&gt; (html (:p :id "x" :style "foo" "Foo"))
&lt;p id='x' style='foo'&gt;Foo&lt;/p&gt;
NIL
</pre>
        <p>
            For folks who prefer a bit more obvious delineation between the element's attributes and its body, FOO supports an alternative syntax: if the first element of a list is itself a list with a keyword as <i>its</i> first element, then the outer list represents an HTML element with that keyword indicating the tag, with the <code><b>REST</b></code> of the nested list as the attributes, and with the <code><b>REST</b></code> of the outer list as the body. Thus, you could write the previous two expressions like this:
        </p>
        <pre>
HTML&gt; (html ((:p :style "foo") "Foo"))
&lt;p style='foo'&gt;Foo&lt;/p&gt;
NIL
HTML&gt; (html ((:p :id "x" :style "foo") "Foo"))
&lt;p id='x' style='foo'&gt;Foo&lt;/p&gt;
NIL
</pre>
        <p>
            The following function tests whether a given object matches either of these syntaxes:
        </p>
        <pre>
(defun cons-form-p (form &amp;optional (test #'keywordp))
  (and (consp form)
       (or (funcall test (car form))
           (and (consp (car form)) (funcall test (caar form))))))
</pre>
        <p>
            You should parameterize the <code>test</code> function because later you'll need to test the same two syntaxes with a slightly different predicate on the name.
        </p>
        <p>
            To completely abstract the differences between the two syntax variants, you can define a function, <code>parse-cons-form</code>, that takes a form and parses it into three elements, the tag, the attributes plist, and the body list, returning them as multiple values. The code that actually evaluates cons forms will use this function and not have to worry about which syntax was used.
        </p>
        <pre>
(defun parse-cons-form (sexp)
  (if (consp (first sexp))
    (parse-explicit-attributes-sexp sexp)
    (parse-implicit-attributes-sexp sexp)))

(defun parse-explicit-attributes-sexp (sexp)
  (destructuring-bind ((tag &amp;rest attributes) &amp;body body) sexp
    (values tag attributes body)))

(defun parse-implicit-attributes-sexp (sexp)
  (loop with tag = (first sexp)
     for rest on (rest sexp) by #'cddr
     while (and (keywordp (first rest)) (second rest))
     when (second rest)
       collect (first rest) into attributes and
       collect (second rest) into attributes
     end
     finally (return (values tag attributes rest))))
</pre>
        <p>
            Now that you have the basic language specified, you can think about how you're actually going to implement the language processors. How do you get from a series of FOO forms to the desired HTML? As I mentioned previously, you'll be implementing two language processors for FOO: an interpreter that walks a tree of FOO forms and emits the corresponding HTML directly and a compiler that walks a tree and translates it into Common Lisp code that'll emit the same HTML. Both the interpreter and compiler will be built on top of a common foundation of code, which provides support for things such as escaping reserved characters and generating nicely indented output, so it makes sense to start there.
        </p>
        <h2>
            <a name="character-escaping" id="character-escaping">Character Escaping</a>
        </h2>
        <p>
            The first bit of the foundation you'll need to lay is the code that knows how to escape characters with a special meaning in HTML. There are three such characters, and they must not appear in the text of an element or in an attribute value; they are <code>&lt;</code>, <code>&gt;</code>, and <code>&amp;</code>. In element text or attribute values, these characters must be replaced with the <i>character reference entities</i> <code>&amp;lt;</code>, <code>&amp;gt</code>;, and <code>&amp;amp;</code>. Similarly, in attribute values, the quotation marks used to delimit the value must be escaped, <code>'</code> with <code>&amp;apos;</code> and <code>"</code> with <code>&amp;quot;</code>. Additionally, any character can be represented by a numeric character reference entity consisting of an ampersand, followed by a sharp sign, followed by the numeric code as a base 10 integer, and followed by a semicolon. These numeric escapes are sometimes used to embed non-ASCII characters in HTML.
        </p>
        <div class="sidebarhead">
            The Package
        </div>
        <div class="sidebar">
            <p>
                Since FOO is a low-level library, the package you develop it in doesn't rely on much external code--just the usual dependency on names from the <code>COMMON-LISP</code> package and, almost as usual, on the names of the macro-writing macros from <code>COM.GIGAMONKEYS.MACRO-UTILITIES</code>. On the other hand, the package needs to export all the names needed by code that uses FOO. Here's the <code><b>DEFPACKAGE</b></code> from the source that you can download from the book's Web site:
            </p>
            <pre>
(defpackage :com.gigamonkeys.html
  (:use :common-lisp :com.gigamonkeys.macro-utilities)
  (:export :with-html-output
           :in-html-style
           :define-html-macro
           :html
           :emit-html
           :&amp;attributes))
</pre>
        </div>
        <p>
            The following function accepts a single character and returns a string containing a character reference entity for that character:
        </p>
        <pre>
(defun escape-char (char)
  (case char
    (#\&amp; "&amp;amp;")
    (#\&lt; "&amp;lt;")
    (#\&gt; "&amp;gt;")
    (#\' "&amp;apos;")
    (#\" "&amp;quot;")
    (t (format nil "&amp;#~d;" (char-code char)))))
</pre>
        <p>
            You can use this function as the basis for a function, <code>escape</code>, that takes a string and a sequence of characters and returns a copy of the first argument with all occurrences of the characters in the second argument replaced with the corresponding character entity returned by <code>escape-char</code>.
        </p>
        <pre>
(defun escape (in to-escape)
  (flet ((needs-escape-p (char) (find char to-escape)))
    (with-output-to-string (out)
      (loop for start = 0 then (1+ pos)
            for pos = (position-if #'needs-escape-p in :start start)
            do (write-sequence in out :start start :end pos)
            when pos do (write-sequence (escape-char (char in pos)) out)
            while pos))))
</pre>
        <p>
            You can also define two parameters: <code>*element-escapes*</code>, which contains the characters you need to escape in normal element data, and <code>*attribute-escapes*</code>, which contains the set of characters to be escaped in attribute values.
        </p>
        <pre>
(defparameter *element-escapes* "&lt;&gt;&amp;")
(defparameter *attribute-escapes* "&lt;&gt;&amp;\"'")
</pre>
        <p>
            Here are some examples:
        </p>
        <pre>
HTML&gt; (escape "foo &amp; bar" *element-escapes*)
"foo &amp;amp; bar"
HTML&gt; (escape "foo &amp; 'bar'" *element-escapes*)
"foo &amp;amp; 'bar'"
HTML&gt; (escape "foo &amp; 'bar'" *attribute-escapes*)
"foo &amp;amp; &amp;apos;bar&amp;apos;"
</pre>
        <p>
            Finally, you'll need a variable, <code>*escapes*</code>, that will be bound to the set of characters that need to be escaped. It's initially set to the value of <code>*element-escapes*</code>, but when generating attributes, it will, as you'll see, be rebound to the value of <code>*attribute-escapes*</code>.
        </p>
        <pre>
(defvar *escapes* *element-escapes*)
</pre>
        <h2>
            <a name="indenting-printer" id="indenting-printer">Indenting Printer</a>
        </h2>
        <p>
            To handle generating nicely indented output, you can define a class <code>indenting-printer</code>, which wraps around an output stream, and functions that use an instance of that class to emit strings to the stream while keeping track of when it's at the beginning of the line. The class looks like this:
        </p>
        <pre>
(defclass indenting-printer ()
  ((out                 :accessor out                 :initarg :out)
   (beginning-of-line-p :accessor beginning-of-line-p :initform t)
   (indentation         :accessor indentation         :initform 0)
   (indenting-p         :accessor indenting-p         :initform t)))
</pre>
        <p>
            The main function that operates on <code>indenting-printer</code>s is <code>emit</code>, which takes the printer and a string and emits the string to the printer's output stream, keeping track of when it emits a newline so it can reset the <code>beginning-of-line-p</code> slot.
        </p>
        <pre>
(defun emit (ip string)
  (loop for start = 0 then (1+ pos)
     for pos = (position #\Newline string :start start)
     do (emit/no-newlines ip string :start start :end pos)
     when pos do (emit-newline ip)
     while pos))
</pre>
        <p>
            To actually emit the string, it uses the function <code>emit/no-newlines</code>, which emits any needed indentation, via the helper <code>indent-if-necessary</code>, and then writes the string to the stream. This function can also be called directly by other code to emit a string that's known not to contain any newlines.
        </p>
        <pre>
(defun emit/no-newlines (ip string &amp;key (start 0) end)
  (indent-if-necessary ip)
  (write-sequence string (out ip) :start start :end end)
  (unless (zerop (- (or end (length string)) start))
    (setf (beginning-of-line-p ip) nil)))
</pre>
        <p>
            The helper <code>indent-if-necessary</code> checks <code>beginning-of-line-p</code> and <code>indenting-p</code> to determine whether it needs to emit indentation and, if they're both true, emits as many spaces as indicated by the value of <code>indentation</code>. Code that uses the <code>indenting-printer</code> can control the indentation by manipulating the <code>indentation</code> and <code>indenting-p</code> slots. Incrementing and decrementing <code>indentation</code> changes the number of leading spaces, while setting <code>indenting-p</code> to <code><b>NIL</b></code> can temporarily turn off indentation.
        </p>
        <pre>
(defun indent-if-necessary (ip)
  (when (and (beginning-of-line-p ip) (indenting-p ip))
    (loop repeat (indentation ip) do (write-char #\Space (out ip)))
    (setf (beginning-of-line-p ip) nil)))
</pre>
        <p>
            The last two functions in the <code>indenting-printer</code> API are <code>emit-newline</code> and <code>emit-freshline</code>, which are both used to emit a newline character, similar to the <code>~%</code> and <code>~&amp;</code> <code><b>FORMAT</b></code> directives. That is, the only difference is that <code>emit-newline</code> always emits a newline, while <code>emit-freshline</code> does so only if <code>beginning-of-line-p</code> is false. Thus, multiple calls to <code>emit-freshline</code> without any intervening <code>emit</code>s won't result in a blank line. This is handy when one piece of code wants to generate some output that should end with a newline while another piece of code wants to generate some output that should start on a newline but you don't want a blank line between the two bits of output.
        </p>
        <pre>
(defun emit-newline (ip)
  (write-char #\Newline (out ip))
  (setf (beginning-of-line-p ip) t))

(defun emit-freshline (ip)
  (unless (beginning-of-line-p ip) (emit-newline ip)))
</pre>
        <p>
            With those preliminaries out of the way, you're ready to get to the guts of the FOO processor.
        </p>
        <h2>
            <a name="html-processor-interface" id="html-processor-interface">HTML Processor Interface</a>
        </h2>
        <p>
            Now you're ready to define the interface that'll be used by the FOO language processor to emit HTML. You can define this interface as a set of generic functions because you'll need two implementations--one that actually emits HTML and another that the <code>html</code> macro can use to collect a list of actions that need to be performed, which can then be optimized and compiled into code that emits the same output in a more efficient way. I'll call this set of generic functions the <i>backend interface</i>. It consists of the following eight generic functions:
        </p>
        <pre>
(defgeneric raw-string (processor string &amp;optional newlines-p))

(defgeneric newline (processor))

(defgeneric freshline (processor))

(defgeneric indent (processor))

(defgeneric unindent (processor))

(defgeneric toggle-indenting (processor))

(defgeneric embed-value (processor value))

(defgeneric embed-code (processor code))
</pre>
        <p>
            While several of these functions have obvious correspondence to <code>indenting-printer</code> functions, it's important to understand that these generic functions define the abstract operations that are used by the FOO language processors and won't always be implemented in terms of calls to the <code>indenting-printer</code> functions.
        </p>
        <p>
            That said, perhaps the easiest way to understand the semantics of these abstract operations is to look at the concrete implementations of the methods specialized on <code>html-pretty-printer</code>, the class used to generate human-readable HTML.
        </p>
        <h2>
            <a name="the-pretty-printer-backend" id="the-pretty-printer-backend">The Pretty Printer Backend</a>
        </h2>
        <p>
            You can start by defining a class with two slots--one to hold an instance of <code>indenting-printer</code> and one to hold the tab width--the number of spaces you want to increase the indentation for each level of nesting of HTML elements.
        </p>
        <pre>
(defclass html-pretty-printer ()
  ((printer   :accessor printer   :initarg :printer)
   (tab-width :accessor tab-width :initarg :tab-width :initform 2)))
</pre>
        <p>
            Now you can implement methods specialized on <code>html-pretty-printer</code> on the eight generic functions that make up the backend interface.
        </p>
        <p>
            The FOO processors use the <code>raw-string</code> function to emit strings that don't need character escaping, either because you actually want to emit normally reserved characters or because all reserved characters have already been escaped. Usually <code>raw-string</code> is invoked with strings that don't contain newlines, so the default behavior is to use <code>emit/no-newlines</code> unless the caller specifies a non-<code><b>NIL</b></code> <code>newlines-p</code> argument.
        </p>
        <pre>
(defmethod raw-string ((pp html-pretty-printer) string &amp;optional newlines-p)
  (if newlines-p
    (emit (printer pp) string)
    (emit/no-newlines (printer pp) string)))
</pre>
        <p>
            The functions <code>newline</code>, <code>freshline</code>, <code>indent</code>, <code>unindent</code>, and <code>toggle-indenting</code> implement fairly straightforward manipulations of the underlying <code>indenting-printer</code>. The only wrinkle is that the HTML pretty printer generates pretty output only when the dynamic variable <code>*pretty*</code> is true. When it's <code><b>NIL</b></code>, you should generate compact HTML with no unnecessary whitespace. So, these methods, with the exception of <code>newline</code>, all check <code>*pretty*</code> before doing anything:<sup>5</sup>
        </p>
        <pre>
(defmethod newline ((pp html-pretty-printer))
  (emit-newline (printer pp)))

(defmethod freshline ((pp html-pretty-printer))
  (when *pretty* (emit-freshline (printer pp))))

(defmethod indent ((pp html-pretty-printer))
  (when *pretty* 
    (incf (indentation (printer pp)) (tab-width pp))))

(defmethod unindent ((pp html-pretty-printer))
  (when *pretty* 
    (decf (indentation (printer pp)) (tab-width pp))))

(defmethod toggle-indenting ((pp html-pretty-printer))
  (when *pretty* 
    (with-slots (indenting-p) (printer pp)
      (setf indenting-p (not indenting-p)))))
</pre>
        <p>
            Finally, the functions <code>embed-value</code> and <code>embed-code</code> are used only by the FOO compiler--<code>embed-value</code> is used to generate code that'll emit the value of a Common Lisp expression, while <code>embed-code</code> is used to embed a bit of code to be run and its result discarded. In the interpreter, you can't meaningfully evaluate embedded Lisp code, so the methods on these functions always signal an error.
        </p>
        <pre>
(defmethod embed-value ((pp html-pretty-printer) value)
  (error "Can't embed values when  interpreting. Value: ~s" value))

(defmethod embed-code ((pp html-pretty-printer) code)
  (error "Can't embed code when interpreting. Code: ~s" code))
</pre>
        <div class="sidebarhead">
            Using Conditions to Have Your Cake and Eat It Too
        </div>
        <div class="sidebar">
            <p>
                An alternate approach would be to use <code><b>EVAL</b></code> to evaluate Lisp expressions in the interpreter. The problem with this approach is that <code><b>EVAL</b></code> has no access to the lexical environment. Thus, there's no way to make something like this work:
            </p>
            <pre>
(let ((x 10)) (emit-html '(:p x)))
</pre>
            <p>
                when <code>x</code> is a lexical variable. The symbol <code>x</code> that's passed to <code>emit-html</code> at runtime has no particular connection to the lexical variable named with the same symbol. The Lisp compiler arranges for references to <code>x</code> in the code to refer to the variable, but after the code is compiled, there's no longer necessarily any association between the name <code>x</code> and that variable. This is the main reason that when you think <code><b>EVAL</b></code> is the solution to your problem, you're probably wrong.
            </p>
            <p>
                However, if <code>x</code> was a dynamic variable, declared with <code><b>DEFVAR</b></code> or <code><b>DEFPARAMETER</b></code> (and likely named <code>*x*</code> instead of <code>x</code>), <code><b>EVAL</b></code> could get at its value. Thus, it might be useful to allow the FOO interpreter to use <code><b>EVAL</b></code> in some situations. But it's a bad idea to always use <code><b>EVAL</b></code>. You can get the best of both worlds by combining the idea of using <code><b>EVAL</b></code> with the condition system.
            </p>
            <p>
                First define some error classes that you can signal when <code>embed-value</code> and <code>embed-code</code> are called in the interpreter.
            </p>
            <pre>
(define-condition embedded-lisp-in-interpreter (error)
  ((form :initarg :form :reader form)))
</pre>
            <pre>
(define-condition value-in-interpreter (embedded-lisp-in-interpreter) ()
  (:report
   (lambda (c s) 
     (format s "Can't embed values when interpreting. Value: ~s" (form c)))))
</pre>
            <pre>
(define-condition code-in-interpreter (embedded-lisp-in-interpreter) ()
  (:report
   (lambda (c s) 
     (format s "Can't embed code when interpreting. Code: ~s" (form c)))))
</pre>
            <p>
                Now you can implement <code>embed-value</code> and <code>embed-code</code> to signal those errors <i>and</i> provide a restart that'll evaluate the form with <code><b>EVAL</b></code>.
            </p>
            <pre>
(defmethod embed-value ((pp html-pretty-printer) value)
  (restart-case (error 'value-in-interpreter :form value)
    (evaluate ()
      :report (lambda (s) (format s "EVAL ~s in null lexical environment." value))
      (raw-string pp (escape (princ-to-string (eval value)) *escapes*) t))))
</pre>
            <pre>
(defmethod embed-code ((pp html-pretty-printer) code)
  (restart-case (error 'code-in-interpreter :form code)
    (evaluate ()
      :report (lambda (s) (format s "EVAL ~s in null lexical environment." code))
      (eval code))))
</pre>
            <p>
                Now you can do something like this:
            </p>
            <pre>
HTML&gt; (defvar *x* 10)
*X*
HTML&gt; (emit-html '(:p *x*))
</pre>
            <p>
                and you'll get dropped into the debugger with this message:
            </p>
            <pre>
Can't embed values when interpreting. Value: *X*
   [Condition of type VALUE-IN-INTERPRETER]
</pre>
            <pre>
Restarts:
  0: [EVALUATE] EVAL *X* in null lexical environment.
  1: [ABORT] Abort handling SLIME request.
  2: [ABORT] Abort entirely from this process.
</pre>
            <p>
                If you invoke the <code>evaluate</code> restart, <code>embed-value</code> will <code><b>EVAL</b></code> <code>*x*</code>, get the value <code>10</code>, and generate this HTML:
            </p>
            <pre>
&lt;p&gt;10&lt;/p&gt;
</pre>
            <p>
                Then, as a convenience, you can provide restart functions--functions that invoke the <code>evaluate</code> restart--in certain situations. The <code>evaluate</code> restart function unconditionally invokes the restart, while <code>eval-dynamic-variables</code> and <code>eval-code</code> invoke it only if the form in the condition is a dynamic variable or potential code.
            </p>
            <pre>
(defun evaluate (&amp;optional condition)
  (declare (ignore condition))
  (invoke-restart 'evaluate))
</pre>
            <pre>
(defun eval-dynamic-variables (&amp;optional condition)
  (when (and (symbolp (form condition)) (boundp (form condition)))
    (evaluate)))
</pre>
            <pre>
(defun eval-code (&amp;optional condition)
  (when (consp (form condition))
    (evaluate)))
</pre>
            <p>
                Now you can use <code><b>HANDLER-BIND</b></code> to set up a handler to automatically invoke the <code>evaluate</code> restart for you.
            </p>
            <pre>
HTML&gt; (handler-bind ((value-in-interpreter #'evaluate)) (emit-html '(:p *x*)))
&lt;p&gt;10&lt;/p&gt;
T
</pre>
            <p>
                Finally, you can define a macro to provide a nicer syntax for binding handlers for the two kinds of errors.
            </p>
            <pre>
(defmacro with-dynamic-evaluation ((&amp;key values code) &amp;body body)
  `(handler-bind (
       ,@(if values `((value-in-interpreter #'evaluate)))
       ,@(if code `((code-in-interpreter #'evaluate))))
     ,@body))
</pre>
            <p>
                With this macro defined, you can write this:
            </p>
            <pre>
HTML&gt; (with-dynamic-evaluation (:values t) (emit-html '(:p *x*)))
&lt;p&gt;10&lt;/p&gt;
T
</pre>
        </div>
        <h2>
            <a name="the-basic-evaluation-rule" id="the-basic-evaluation-rule">The Basic Evaluation Rule</a>
        </h2>
        <p>
            Now to connect the FOO language to the processor interface, all you need is a function that takes an object and processes it, invoking the appropriate processor functions to generate HTML. For instance, when given a simple form like this:
        </p>
        <pre>
(:p "Foo")
</pre>
        <p>
            this function might execute this sequence of calls on the processor:
        </p>
        <pre>
(freshline processor)
(raw-string processor "&lt;p" nil)
(raw-string processor "&gt;" nil)
(raw-string processor "Foo" nil)
(raw-string processor "&lt;/p&gt;" nil)
(freshline processor)
</pre>
        <p>
            For now you can define a simple function that just checks whether a form is, in fact, a legal FOO form and, if it is, hands it off to the function <code>process-sexp-html</code> for processing. In the next chapter, you'll add some bells and whistles to this function to allow it to handle macros and special operators. But for now it looks like this:
        </p>
        <pre>
(defun process (processor form)
  (if (sexp-html-p form)
    (process-sexp-html processor form)
    (error "Malformed FOO form: ~s" form)))
</pre>
        <p>
            The function <code>sexp-html-p</code> determines whether the given object is a legal FOO expression, either a self-evaluating form or a properly formatted cons.
        </p>
        <pre>
(defun sexp-html-p (form)
  (or (self-evaluating-p form) (cons-form-p form)))
</pre>
        <p>
            Self-evaluating forms are easily handled: just convert to a string with <code><b>PRINC-TO-STRING</b></code> and escape the characters in the variable <code>*escapes*</code>, which, as you'll recall, is initially bound to the value of <code>*element-escapes*</code>. Cons forms you pass off to <code>process-cons-sexp-html</code>.
        </p>
        <pre>
(defun process-sexp-html (processor form)
  (if (self-evaluating-p form)
    (raw-string processor (escape (princ-to-string form) *escapes*) t)
    (process-cons-sexp-html processor form)))
</pre>
        <p>
            The function <code>process-cons-sexp-html</code> is then responsible for emitting the opening tag, any attributes, the body, and the closing tag. The main complication here is that to generate pretty HTML, you need to emit fresh lines and adjust the indentation according to the type of the element being emitted. You can categorize all the elements defined in HTML into one of three categories: block, paragraph, and inline. Block elements--such as <code>body</code> and <code>ul</code>--are emitted with fresh lines before and after both their opening and closing tags and with their contents indented one level. Paragraph elements--such as <code>p</code>, <code>li</code>, and <code>blockquote</code>--are emitted with a fresh line before the opening tag and after the closing tag. Inline elements are simply emitted in line. The following three parameters list the elements of each type:
        </p>
        <pre>
(defparameter *block-elements*
  '(:body :colgroup :dl :fieldset :form :head :html :map :noscript :object
    :ol :optgroup :pre :script :select :style :table :tbody :tfoot :thead
    :tr :ul))

(defparameter *paragraph-elements*
  '(:area :base :blockquote :br :button :caption :col :dd :div :dt :h1
    :h2 :h3 :h4 :h5 :h6 :hr :input :li :link :meta :option :p :param
    :td :textarea :th :title))

(defparameter *inline-elements*
  '(:a :abbr :acronym :address :b :bdo :big :cite :code :del :dfn :em
    :i :img :ins :kbd :label :legend :q :samp :small :span :strong :sub
    :sup :tt :var))
</pre>
        <p>
            The functions <code>block-element-p</code> and <code>paragraph-element-p</code> test whether a given tag is a member of the corresponding list.<sup>6</sup>
        </p>
        <pre>
(defun block-element-p (tag) (find tag *block-elements*))

(defun paragraph-element-p (tag) (find tag *paragraph-elements*))
</pre>
        <p>
            Two other categorizations with their own predicates are the elements that are always empty, such as <code>br</code> and <code>hr</code>, and the three elements, <code>pre</code>, <code>style</code>, and <code>script</code>, in which whitespace is supposed to be preserved. The former are handled specially when generating regular HTML (in other words, not XHTML) since they're not supposed to have a closing tag. And when emitting the three tags in which whitespace is preserved, you can temporarily turn off indentation so the pretty printer doesn't add any spaces that aren't part of the element's actual contents.
        </p>
        <pre>
(defparameter *empty-elements*
  '(:area :base :br :col :hr :img :input :link :meta :param))

(defparameter *preserve-whitespace-elements* '(:pre :script :style))

(defun empty-element-p (tag) (find tag *empty-elements*))

(defun preserve-whitespace-p (tag) (find tag *preserve-whitespace-elements*))
</pre>
        <p>
            The last piece of information you need when generating HTML is whether you're generating XHTML since that affects how you emit empty elements.
        </p>
        <pre>
(defparameter *xhtml* nil)
</pre>
        <p>
            With all that information, you're ready to process a cons FOO form. You use <code>parse-cons-form</code> to parse the list into three parts, the tag symbol, a possibly empty plist of attribute key/value pairs, and a possibly empty list of body forms. You then emit the opening tag, the body, and the closing tag with the helper functions <code>emit-open-tag</code>, <code>emit-element-body</code>, and <code>emit-close-tag</code>.
        </p>
        <pre>
(defun process-cons-sexp-html (processor form)
  (when (string= *escapes* *attribute-escapes*)
    (error "Can't use cons forms in attributes: ~a" form))
  (multiple-value-bind (tag attributes body) (parse-cons-form form)
    (emit-open-tag     processor tag body attributes)
    (emit-element-body processor tag body)
    (emit-close-tag    processor tag body)))
</pre>
        <p>
            In <code>emit-open-tag</code> you have to call <code>freshline</code> when appropriate and then emit the attributes with <code>emit-attributes</code>. You need to pass the element's body to <code>emit-open-tag</code> so when it's emitting XHTML, it knows whether to finish the tag with <code>/&gt;</code> or <code>&gt;</code>.
        </p>
        <pre>
(defun emit-open-tag (processor tag body-p attributes)
  (when (or (paragraph-element-p tag) (block-element-p tag))
    (freshline processor))
  (raw-string processor (format nil "&lt;~(~a~)" tag))
  (emit-attributes processor attributes)
  (raw-string processor (if (and *xhtml* (not body-p)) "/&gt;" "&gt;")))
</pre>
        <p>
            In <code>emit-attributes</code> the attribute names aren't evaluated since they must be keyword symbols, but you should invoke the top-level <code>process</code> function to evaluate the attribute values, binding <code>*escapes*</code> to <code>*attribute-escapes*</code>. As a convenience for specifying boolean attributes, whose value should be the name of the attribute, if the value is <code><b>T</b></code>--not just any true value but actually <code><b>T</b></code>--then you replace the value with the name of the attribute.<sup>7</sup>
        </p>
        <pre>
(defun emit-attributes (processor attributes)
  (loop for (k v) on attributes by #'cddr do
       (raw-string processor (format nil " ~(~a~)='" k))
       (let ((*escapes* *attribute-escapes*))
         (process processor (if (eql v t) (string-downcase k) v)))
       (raw-string processor "'")))
</pre>
        <p>
            Emitting the element's body is similar to emitting the attribute values: you can loop through the body calling <code>process</code> to evaluate each form. The rest of the code is dedicated to emitting fresh lines and adjusting the indentation as appropriate for the type of element.
        </p>
        <pre>
(defun emit-element-body (processor tag body)
  (when (block-element-p tag)
    (freshline processor)
    (indent processor))
  (when (preserve-whitespace-p tag) (toggle-indenting processor))
  (dolist (item body)  (process processor item))
  (when (preserve-whitespace-p tag) (toggle-indenting processor))
  (when (block-element-p tag)
    (unindent processor)
    (freshline processor)))
</pre>
        <p>
            Finally, <code>emit-close-tag</code>, as you'd probably expect, emits the closing tag (unless no closing tag is necessary, such as when the body is empty and you're either emitting XHTML or the element is one of the special empty elements). Regardless of whether you actually emit a close tag, you need to emit a final fresh line for block and paragraph elements.
        </p>
        <pre>
(defun emit-close-tag (processor tag body-p)
  (unless (and (or *xhtml* (empty-element-p tag)) (not body-p))
    (raw-string processor (format nil "&lt;/~(~a~)&gt;" tag)))
  (when (or (paragraph-element-p tag) (block-element-p tag))
    (freshline processor)))
</pre>
        <p>
            The function <code>process</code> is the basic FOO interpreter. To make it a bit easier to use, you can define a function, <code>emit-html</code>, that invokes <code>process</code>, passing it an <code>html-pretty-printer</code> and a form to evaluate. You can define and use a helper function, <code>get-pretty-printer</code>, to get the pretty printer, which returns the current value of <code>*html-pretty-printer*</code> if it's bound; otherwise, it makes a new instance of <code>html-pretty-printer</code> with <code>*html-output*</code> as its output stream.
        </p>
        <pre>
(defun emit-html (sexp) (process (get-pretty-printer) sexp))

(defun get-pretty-printer ()
  (or *html-pretty-printer*
      (make-instance 
       'html-pretty-printer
       :printer (make-instance 'indenting-printer :out *html-output*))))
</pre>
        <p>
            With this function, you can emit HTML to <code>*html-output*</code>. Rather than expose the variable <code>*html-output*</code> as part of FOO's public API, you should define a macro, <code>with-html-output</code>, that takes care of binding the stream for you. It also lets you specify whether you want pretty HTML output, defaulting to the value of the variable <code>*pretty*</code>.
        </p>
        <pre>
(defmacro with-html-output ((stream &amp;key (pretty *pretty*)) &amp;body body)
  `(let* ((*html-output* ,stream)
          (*pretty* ,pretty))
    ,@body))
</pre>
        <p>
            So, if you wanted to use <code>emit-html</code> to generate HTML to a file, you could write the following:
        </p>
        <pre>
(with-open-file (out "foo.html" :direction output)
  (with-html-output (out :pretty t)
    (emit-html *some-foo-expression*)))
</pre>
        <h2>
            <a name="whats-next" id="whats-next">What's Next?</a>
        </h2>
        <p>
            In the next chapter, you'll look at how to implement a macro that compiles FOO expressions into Common Lisp so you can embed HTML generation code directly into your Lisp programs. You'll also extend the FOO language to make it a bit more expressive by adding its own flavor of special operators and macros.
        </p>
        <hr>
        <div class="notes">
            <p>
                <sup>1</sup>In fact, it's probably <i>too</i> expressive since it can also generate all sorts of output that's not even vaguely legal HTML. Of course, that might be a feature if you need to generate HTML that's not strictly correct to compensate for buggy Web browsers. Also, it's common for language processors to accept programs that are syntactically correct and otherwise well formed that'll nonetheless provoke undefined behavior when run.
            </p>
            <p>
                <sup>2</sup>Well, almost every tag. Certain tags such as <code>IMG</code> and <code>BR</code> don't. You'll deal with those in the section "The Basic Evaluation Rule."
            </p>
            <p>
                <sup>3</sup>In the strict language of the Common Lisp standard, keyword symbols aren't <i>self-evaluating</i>, though they do, in fact, evaluate to themselves. See section 3.1.2.1.3 of the language standard or HyperSpec for a brief discussion.
            </p>
            <p>
                <sup>4</sup>The requirement to use objects that the Lisp reader knows how to read isn't a hard-and-fast one. Since the Lisp reader is itself customizable, you could also define a new reader-level syntax for a new kind of object. But that tends to be more trouble than it's worth.
            </p>
            <p>
                <sup>5</sup>Another, more purely object-oriented, approach would be to define two classes, perhaps <code>html-pretty-printer</code> and <code>html-raw-printer</code>, and then define no-op methods specialized on <code>html-raw-printer</code> for the methods that should do stuff only when <code>*pretty*</code> is true. However, in this case, after defining all the no-op methods, you'd end up with more code, and then you'd have the hassle of making sure you created an instance of the right class at the right time. But in general, using polymorphism to replace conditionals is a good strategy.
            </p>
            <p>
                <sup>6</sup>You don't need a predicate for <code>*inline-elements*</code> since you only ever test for block and paragraph elements. I include the parameter here for completeness.
            </p>
            <p>
                <sup>7</sup>While XHTML requires boolean attributes to be notated with their name as the value to indicate a true value, in HTML it's also legal to simply include the name of the attribute with no value, for example, <code><b>&lt;option selected&gt;</b></code> rather than <code><b>&lt;option selected='selected'&gt;</b></code>. All HTML 4.0-compatible browsers should understand both forms, but some buggy browsers understand only the no-value form for certain attributes. If you need to generate HTML for such browsers, you'll need to hack <code>emit-attributes</code> to emit those attributes a bit differently.
            </p>
        </div>
        <div class="copyright">
            Copyright © 2003-2005, Peter Seibel
        </div>
    </body>
</html>
